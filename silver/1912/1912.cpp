#include <iostream>

using namespace std;

#define Max(a,b) (a>b?a:b)

int main() {
  int N, n;

  scanf("%d", &N);

  int DP[N + 1];
  int t[N + 1];

  DP[0] = 0;
  t[0] = 0;

  for (int i=1; i<=N; i++) {
    scanf("%d", &n);

    t[i] = n;
    DP[i] = i < 2 ? t[i] : Max(Max(DP[i - 2] + t[i - 1] + n, n), DP[i - 1]);
  }

  for(int i=1; i<=N; i++) printf("%d ", DP[i]);

  return 0;
}

// 점화식을 생각해보자
//   10
//   10     -4     3     1      5     6     -35     12     21     -1
//   10     10    10    10     10    10      10     12     33     33
//                여기서 어떻게 처리할지 고민하면됨(10 + 3은 13인데 연속된 수가 아니라 10이어야함)
// 이거 다 틀림. 6까지 모두 다 더한게 제일 큼. 10 -4 3 1 5 6 = 21.
// 그냥 로직 자체가 틀림
// 다시 구하기

// 10   -4  3   1   5   6   -35   12  21  -1
// 10   10 10  14  16  25    25   25  58  58

// 연속된 수
// 3  + 1 + 10 = 14
// 1
// 10

// 연속된 수라고 하면 이전거와 비교해야댐
// 

// DP[i - 1]에는 이전까지의 연속된 수의 합
// DP[i]는 현재값을 포함하여 연속된 수의 합
// t[i]는 현재 입력값
// t[i - 1]는 이전 입력값

// 여기서 어떻게 연속된 수를 체크할 수 있을까
// 